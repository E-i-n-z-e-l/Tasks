package LeetCode.Task004;

import java.util.Arrays;
/*
                                        ТЕОРИЯ
    1. Размер массива: В Java массивы имеют фиксированный размер после создания. Это означает, что вы не
    можете изменить размер массива прямо так, как вы сделали бы, скажем, со списком (ArrayList) в Java.
    Когда вы объявляете массив и выделяете ему память, его размер фиксируется и не может быть изменен без
    создания нового массива.

    2. Расширение массива: Если вы хотите увеличить размер массива, вам нужно создать новый массив большего
    размера и скопировать в него все элементы из старого массива. В Java это часто делается с помощью методов
    System.arraycopy() или Arrays.copyOf().

    3. Слияние массивов: При слиянии двух массивов в один важно учитывать, что переполнение массивов может
    привести к выходу за пределы их длины. Это может произойти, например, если пытаетесь поместить большее
    количество элементов, чем длина массива, или при неправильном управлении индексами в циклах.

    4. Добавление значений в массив: Когда вы добавляете новое значение в массив в Java, вы обычно просто
    присваиваете значение некоторому индексу в массиве. Однако, если вы пытаетесь присвоить значение по индексу,
    который находится за пределами текущей длины массива, это вызовет ошибку "ArrayIndexOutOfBoundsException".
    Это происходит потому, что Java не автоматически расширяет массив, если вы обращаетесь к индексу, выходящему
    за его текущие границы.

 */

/** ЗАДАЧА.<p>
 * Даны два целочисленных массива nums1 и nums2, отсортированных в неубывающем порядке,
 * а также два целых числа m и n, представляющих количество элементов в nums1 и nums2 соответственно.
 * <p>
 * Объедините nums1 и nums2 в один массив, отсортированный в неубывающем порядке.
 * <p>
 * Отсортированный итоговый массив не должен возвращаться функцией, а должен быть сохранен внутри массива nums1.
 * Для этого nums1 имеет длину m + n, где первые m элементов обозначают элементы, которые должны быть объединены,
 * а последние n элементов установлены в 0 и должны быть проигнорированы. Длина nums2 равна n.
 */
public class Solution {
    /**
     * Метод принимает два целочисленных массива и два числа, которые являются размерами этих массивов,
     * за исключением нулей, которые могут иметься в этих массивах.
     *
     * @param nums1
     * @param m
     * @param nums2
     * @param n
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // Индексы для отслеживания текущих элементов в массивах nums1 и nums2.
        int i = m - 1; // Записываем последний элемент массива nums1.
        int j = n - 1; // Записываем последний элемент массива nums2.
        // Индекс для записи результирующих значений в nums1.
        int k = m + n - 1; //

        /*
         Алгоритм слияния двух отсортированных массивов:

         - Мы начинаем с конца обоих массивов и сравниваем их элементы.

         - Если элемент в nums1 больше, мы записываем его в конец nums1 (индекс k--), затем уменьшаем индекс i--.

         - Если элемент в nums2 больше или равен, мы записываем его в конец nums1 (индекс k--), затем уменьшаем
         индекс j--.

         По мере итераций цикла, когда мы просматриваем значения в nums1 и nums2, и записываем их в конец nums1,
         по мере необходимости текущий элемент в nums1 сравнивается с текущим элементом в nums2, и, в зависимости
         от результата сравнения, он упорядочивается в конце nums1.

        Следовательно, после выполнения этого цикла, когда происходит слияние и упорядочивание nums1 и nums2,
        нам остается только переместить оставшиеся элементы из nums2, если таковые имеются, в nums1.

        Таким образом, цикл обеспечивает слияние и упорядочивание массива nums1, используя значения из nums2,
        когда это необходимо.
         */
        while (i >= 0 && j >= 0) { // Главное чтобы не были 0, ибо 0 удаляются.
            if (nums1[i] > nums2[j]) { // Сравниваем два числа по индексам с конца массива.
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }

    /**
     * Метод сначала перемещает значения из массива nums2 в nums1, а потом сортирует его.
     * При маленьких размеров массива этот метод быстрее. Чем больше массив, тем дольше работает метод.
     * @param nums1
     * @param m
     * @param nums2
     * @param n
     */
    public void merge2(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i < n; i++) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums1 = new int[]{1};
        int[] nums2 = new int[]{0};
        solution.merge(nums1, 1, nums2, 0);
        System.out.println(Arrays.toString(nums1));

        int[] nums3 = new int[]{1, 2, 3, 0, 0, 0};
        int[] nums4 = new int[]{2, 5, 6};
        solution.merge2(nums3, 3, nums4, 3);
        System.out.println(Arrays.toString(nums3));

        int[] nums5 = new int[]{1, 2};
        int[] nums6 = new int[]{1};
        solution.merge(nums5, 1, nums6, 0);
        System.out.println(Arrays.toString(nums5));
    }
}
