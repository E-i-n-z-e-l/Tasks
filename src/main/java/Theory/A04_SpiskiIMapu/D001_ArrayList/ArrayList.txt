/**
 * В основе ArrayList лежит идея динамического массива. А именно, возможность добавлять и удалять элементы,
 * при этом будет увеличиваться или уменьшаться по мере необходимости.
 * <p>
 * Пояснение к ArrayList():
 * <p>
 * 1. ArrayList() - создание нового динамического массива. Пример: ArrayList<String> list = new ArrayList<>();
 * <p>
 * 2. ArrayList(Collection <? extends E> c) - принимает другой лист или коллекцию. Пример:
 * ArrayList<String> list2 = new ArrayList<>(list);
 * <p>
 * 3. ArrayList(int initialCapacity) - устанавливает значения начального размера внутреннего массива. Пример:
 * ArrayList<String> list2 = new ArrayList<>(10000);
 * <p>
 * Методы ArrayList()
 * <p>
 * 1. add() - добавление элемента в список;<p>
 * 2. add(int index, E element) - Добавляет элемент element в позицию index. При добавлении происходит сдвиг
 * всех элементов справа от указанного индекса на 1 позицию вправо. Пример: list.add(0, "Amigo");<p>
 * 3. addAll() - добавление всех элементов коллекции collection в список в порядке их расположения в collection.<p>
 * 4. addAll(int index, Collection <? extends E> collection) - Добавление всех элементов collection в список
 * начиная с индекса index. Пример: secondList.addAll(1, list);<p>
 * 5. clear() - удаление всех элементов списка;<p>
 * 6. clone() - озвращает объект-копию массива. Пример: ArrayList<String> copyOfSecondList = (ArrayList<String>) secondList.clone();<p>
 * 7. contains(Object o) - Проверка наличие объекта в списке. Пример: System.out.println(copyOfSecondList.contains("Hello"));
 * возвращает boolean-значение.<p>
 * 8. ensureCapacity(int minCapacity) - Увеличивает размер внутреннего массива, чтобы в него поместилось количество
 * элементов, переданных в minCapacity. Если массив достаточно вместителен, никакие преобразования не производятся.
 * forEach(Consumer<? super E> action) - В классе ArrayList есть метод для обработки каждого элемента, который
 * называется также, forEach. В качестве аргумента передается реализация интерфейса Consumer, в котором нужно
 * переопределить метод accept():<p>
 *     secondList.forEach(new Consumer<String>() {<p>
 *    @Override<p>
 *    public void accept(String s) {<p>
 *        System.out.println(s);<p>
 *    }<p>
 * });<p>
 * 9. get(int index) - Возвращает элемент, который расположен в указанной позиции списка. Время извлечения элемента
 * по индексу всегда будет одинаковым, независимо от размера ArrayList.<p>
 * 10. Метод accept - принимает в качестве аргумента очередной элемент того типа, который хранит в себе ArrayList.<p>
 * 11. indexOf(Object o) - Метод возвращает индекс первого вхождения элемента в списке. Если элемента не существует
 * в списке, метод вернет -1. <p>
 * 12. isEmpty() - Метод возвращает true, если список пустой, false в обратном случае. <p>
 * 13. iterator() - Возвращает итератор для списка для последующего использования в цикле или при любой другой обработке.<p>
 * 14. lastIndexOf(Object o) - возвращается индекс последнего элемента в списке. <p>
 * 15. remove(int index) - Удаление элемента в указанной позиции индекса. После удаления сдвигает все элементы влево
 * для заполнения освободившегося пространства. <p>
 * 16. remove(Object o) - Метод удаляет из списка переданный элемент o. Если элемент присутствует в списке, он удаляется,
 * а все элементы смещаются влево.<p>
 * 17. removeAll(Collection<?> c) - принимает коллекцию элементов, которая будет удалена из списка.<p>
 * 18. set(int index, E element) - Замена элемента в указанной позиции index на переданный element. <p>
 * 19. size() - Лучший способ (практически единственный) для того, чтобы узнать размер массива. <p>
 * 20. sort(Comparator<? super E> c) - сортировка списка. <p>
 * 21. toArray() - Превращает список в фиксированный массив. Обратите внимание, что метод возвращает массив объектов
 * (Object[]). Если необходимо привести список в массив объектов определенного типа, в качестве параметра в метод
 * можно передать массив, куда будут перемещены элементы списков.
 */